<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>CRISP Optical System</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            body {
                background: transparent;
                display: flex;
                justify-content: center;
                align-items: center;
                min-height: 100vh;
                overflow: hidden;
            }
            canvas {
                display: block;
                max-width: 100%;
                height: auto;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");

            // Set canvas size
            const W = 1200;
            const H = 500;
            canvas.width = W;
            canvas.height = H;

            // Neon colors for spectrum
            const spectralColors = [
                "#ff00ff", // magenta
                "#8b00ff", // violet
                "#0066ff", // blue
                "#00ffff", // cyan
                "#00ff66", // green
                "#ffff00", // yellow
                "#ff9900", // orange
                "#ff0044", // red
            ];

            // Wireframe color
            const wireColor = "#00ffff";
            const wireColorDim = "#006666";
            const glowColor = "rgba(0, 255, 255, 0.3)";

            // Optical element positions
            const scene = { x: 50, y: H / 2 };
            const prism1 = { x: 250, y: H / 2, size: 80 };
            const mask = { x: 450, y: H / 2, width: 40, height: 200 };
            const prism2 = { x: 650, y: H / 2, size: 80 };
            const detector = { x: 850, y: H / 2, width: 60, height: 120 };
            const cube = { x: 1020, y: H / 2, size: 100 };

            // Mask pattern (which wavelengths pass)
            const maskPattern = [1, 0, 1, 1, 0, 1, 0, 1]; // 1 = pass, 0 = block

            // Photon particles
            class Photon {
                constructor() {
                    this.reset();
                }

                reset() {
                    this.x = scene.x;
                    this.y = scene.y + (Math.random() - 0.5) * 60;
                    this.phase = 0; // 0: to prism1, 1: dispersing, 2: to mask, 3: to prism2, 4: combining, 5: to detector
                    this.colorIndex = Math.floor(
                        Math.random() * spectralColors.length,
                    );
                    this.color = spectralColors[this.colorIndex];
                    this.speed = 2 + Math.random() * 1.5;
                    this.blocked = false;
                    this.yOffset = 0;
                    this.targetY = 0;
                    this.alpha = 1;
                    this.trail = [];
                }

                update() {
                    // Store trail
                    if (this.phase > 0 && this.phase < 6) {
                        this.trail.push({
                            x: this.x,
                            y: this.y,
                            alpha: this.alpha,
                        });
                        if (this.trail.length > 15) this.trail.shift();
                    }

                    switch (this.phase) {
                        case 0: // Moving to prism 1
                            this.x += this.speed;
                            if (this.x >= prism1.x - 30) {
                                this.phase = 1;
                                // Calculate dispersion target
                                const dispersionRange = 150;
                                this.targetY =
                                    H / 2 -
                                    dispersionRange / 2 +
                                    (this.colorIndex /
                                        (spectralColors.length - 1)) *
                                        dispersionRange;
                            }
                            break;

                        case 1: // Dispersing through prism 1
                            this.x += this.speed;
                            this.y += (this.targetY - this.y) * 0.15;
                            if (this.x >= prism1.x + 50) {
                                this.phase = 2;
                            }
                            break;

                        case 2: // Moving to mask
                            this.x += this.speed;
                            if (this.x >= mask.x - mask.width / 2) {
                                this.phase = 3;
                                // Check if blocked by mask
                                this.blocked =
                                    maskPattern[this.colorIndex] === 0;
                            }
                            break;

                        case 3: // Through mask
                            if (this.blocked) {
                                this.alpha -= 0.1;
                                if (this.alpha <= 0) {
                                    this.reset();
                                    return;
                                }
                            } else {
                                this.x += this.speed;
                                if (this.x >= mask.x + mask.width / 2 + 20) {
                                    this.phase = 4;
                                }
                            }
                            break;

                        case 4: // Moving to prism 2 and recombining
                            this.x += this.speed;
                            this.y += (H / 2 - this.y) * 0.08;
                            if (this.x >= prism2.x + 50) {
                                this.phase = 5;
                            }
                            break;

                        case 5: // Moving to detector
                            this.x += this.speed;
                            if (this.x >= detector.x) {
                                this.phase = 6;
                            }
                            break;

                        case 6: // Hit detector - trigger cube update and reset
                            cubeData[this.colorIndex] = Math.min(
                                1,
                                cubeData[this.colorIndex] + 0.15,
                            );
                            this.reset();
                            break;
                    }
                }

                draw() {
                    if (this.alpha <= 0) return;

                    // Draw trail
                    for (let i = 0; i < this.trail.length; i++) {
                        const t = this.trail[i];
                        const trailAlpha =
                            (i / this.trail.length) * 0.5 * this.alpha;
                        ctx.beginPath();
                        ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
                        ctx.fillStyle = this.color
                            .replace(")", `, ${trailAlpha})`)
                            .replace("rgb", "rgba")
                            .replace("#", "");
                        // Convert hex to rgba
                        const r = parseInt(this.color.slice(1, 3), 16);
                        const g = parseInt(this.color.slice(3, 5), 16);
                        const b = parseInt(this.color.slice(5, 7), 16);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${trailAlpha})`;
                        ctx.fill();
                    }

                    // Draw photon
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    const r = parseInt(this.color.slice(1, 3), 16);
                    const g = parseInt(this.color.slice(3, 5), 16);
                    const b = parseInt(this.color.slice(5, 7), 16);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${this.alpha})`;
                    ctx.shadowColor = this.color;
                    ctx.shadowBlur = 10;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Create photons
            const photons = [];
            for (let i = 0; i < 40; i++) {
                const p = new Photon();
                p.x = Math.random() * 300; // Stagger initial positions
                photons.push(p);
            }

            // Hyperspectral cube data
            let cubeData = new Array(spectralColors.length).fill(0);

            // Decay cube data over time
            setInterval(() => {
                for (let i = 0; i < cubeData.length; i++) {
                    cubeData[i] *= 0.98;
                }
            }, 50);

            // Draw wireframe prism (apex pointing up)
            function drawPrism(x, y, size) {
                const h = (size * Math.sqrt(3)) / 2;

                ctx.strokeStyle = wireColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = wireColor;
                ctx.shadowBlur = 10;

                // Front face - triangle with apex at top
                ctx.beginPath();
                ctx.moveTo(x, y - h / 2); // Top apex
                ctx.lineTo(x - size / 2, y + h / 2); // Bottom left
                ctx.lineTo(x + size / 2, y + h / 2); // Bottom right
                ctx.closePath();
                ctx.stroke();

                // Back edges (depth) for 3D effect
                const depth = 30;
                ctx.strokeStyle = wireColorDim;
                ctx.lineWidth = 1;

                ctx.beginPath();
                // Lines going back from each vertex
                ctx.moveTo(x, y - h / 2);
                ctx.lineTo(x - depth * 0.3, y - h / 2 - depth * 0.2);
                ctx.moveTo(x - size / 2, y + h / 2);
                ctx.lineTo(x - size / 2 - depth * 0.3, y + h / 2 - depth * 0.2);
                ctx.moveTo(x + size / 2, y + h / 2);
                ctx.lineTo(x + size / 2 - depth * 0.3, y + h / 2 - depth * 0.2);
                ctx.stroke();

                ctx.shadowBlur = 0;
            }

            // Draw coded mask
            function drawMask(x, y, width, height) {
                const slotHeight = height / spectralColors.length;

                ctx.strokeStyle = wireColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = wireColor;
                ctx.shadowBlur = 8;

                // Outer frame
                ctx.strokeRect(x - width / 2, y - height / 2, width, height);

                // Slots
                for (let i = 0; i < spectralColors.length; i++) {
                    const slotY = y - height / 2 + i * slotHeight;
                    if (maskPattern[i] === 0) {
                        // Blocked - draw filled bar
                        ctx.fillStyle = "rgba(0, 255, 255, 0.3)";
                        ctx.fillRect(
                            x - width / 2 + 2,
                            slotY + 2,
                            width - 4,
                            slotHeight - 4,
                        );
                    } else {
                        // Open - draw just outline
                        ctx.strokeStyle = wireColorDim;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(
                            x - width / 2 + 2,
                            slotY + 2,
                            width - 4,
                            slotHeight - 4,
                        );
                        ctx.strokeStyle = wireColor;
                        ctx.lineWidth = 2;
                    }
                }
                ctx.shadowBlur = 0;
            }

            // Draw detector array
            function drawDetector(x, y, width, height) {
                ctx.strokeStyle = wireColor;
                ctx.lineWidth = 2;
                ctx.shadowColor = wireColor;
                ctx.shadowBlur = 10;

                // Main frame
                ctx.strokeRect(x - width / 2, y - height / 2, width, height);

                // Pixel grid
                const gridSize = 4;
                const cellW = width / gridSize;
                const cellH = height / gridSize;

                ctx.strokeStyle = wireColorDim;
                ctx.lineWidth = 1;

                for (let i = 1; i < gridSize; i++) {
                    // Vertical lines
                    ctx.beginPath();
                    ctx.moveTo(x - width / 2 + i * cellW, y - height / 2);
                    ctx.lineTo(x - width / 2 + i * cellW, y + height / 2);
                    ctx.stroke();

                    // Horizontal lines
                    ctx.beginPath();
                    ctx.moveTo(x - width / 2, y - height / 2 + i * cellH);
                    ctx.lineTo(x + width / 2, y - height / 2 + i * cellH);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }

            // Draw hyperspectral cube
            function drawCube(x, y, size) {
                const layerHeight = size / spectralColors.length;
                const depth = size * 0.4;
                const width = size;
                const height = size;

                // Draw from back to front
                for (let i = spectralColors.length - 1; i >= 0; i--) {
                    const layerY = y - height / 2 + i * layerHeight;
                    const intensity = cubeData[i];
                    const color = spectralColors[i];

                    // Parse color
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);

                    // Layer offset for 3D effect
                    const offsetX = (spectralColors.length - 1 - i) * 3;
                    const offsetY = (spectralColors.length - 1 - i) * -2;

                    // Fill with intensity
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.1 + intensity * 0.6})`;
                    ctx.fillRect(
                        x - width / 2 + offsetX,
                        layerY + offsetY,
                        width * 0.8,
                        layerHeight - 2,
                    );

                    // Wireframe
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.5 + intensity * 0.5})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        x - width / 2 + offsetX,
                        layerY + offsetY,
                        width * 0.8,
                        layerHeight - 2,
                    );

                    // Side edge for 3D effect
                    if (i < spectralColors.length - 1) {
                        ctx.beginPath();
                        ctx.moveTo(
                            x - width / 2 + offsetX + width * 0.8,
                            layerY + offsetY,
                        );
                        ctx.lineTo(
                            x - width / 2 + offsetX + 3 + width * 0.8,
                            layerY + offsetY - 2,
                        );
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.3)`;
                        ctx.stroke();
                    }
                }

                // Label
                ctx.fillStyle = wireColor;
                ctx.font = "12px monospace";
                ctx.textAlign = "center";
                ctx.fillText("Î»", x + size * 0.5, y + height / 2 + 20);
                ctx.fillText("x", x - size * 0.3, y + height / 2 + 35);
                ctx.fillText("y", x + size * 0.1, y - height / 2 - 25);
            }

            // Draw scene (light source)
            function drawScene(x, y) {
                ctx.strokeStyle = wireColor;
                ctx.lineWidth = 1.5;
                ctx.shadowColor = wireColor;
                ctx.shadowBlur = 5;

                // Simple landscape wireframe
                ctx.beginPath();
                // Mountain
                ctx.moveTo(x - 30, y + 30);
                ctx.lineTo(x, y - 20);
                ctx.lineTo(x + 30, y + 30);
                // Ground line
                ctx.moveTo(x - 40, y + 30);
                ctx.lineTo(x + 40, y + 30);
                // Sun
                ctx.moveTo(x + 25, y - 30);
                ctx.arc(x + 20, y - 35, 8, 0, Math.PI * 2);
                ctx.stroke();

                // Rays emanating
                ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
                for (let i = 0; i < 5; i++) {
                    const angle = -0.3 + i * 0.15;
                    ctx.beginPath();
                    ctx.moveTo(x + 40, y + (i - 2) * 15);
                    ctx.lineTo(x + 80, y + (i - 2) * 12);
                    ctx.stroke();
                }

                ctx.shadowBlur = 0;
            }

            // Draw labels
            function drawLabels() {
                ctx.fillStyle = "rgba(0, 255, 255, 0.7)";
                ctx.font = "11px monospace";
                ctx.textAlign = "center";

                ctx.fillText("SCENE", scene.x, H - 30);
                ctx.fillText("DISPERSE", prism1.x, H - 30);
                ctx.fillText("CODED MASK", mask.x, H - 30);
                ctx.fillText("RECOMBINE", prism2.x, H - 30);
                ctx.fillText("DETECTOR", detector.x, H - 30);
                ctx.fillText("HYPERSPECTRAL", cube.x, H - 30);
                ctx.fillText("DATA CUBE", cube.x, H - 18);
            }

            // Draw optical axis
            function drawOpticalAxis() {
                ctx.strokeStyle = "rgba(0, 255, 255, 0.15)";
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 10]);
                ctx.beginPath();
                ctx.moveTo(80, H / 2);
                ctx.lineTo(W - 80, H / 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Animation loop
            function animate() {
                // Clear with transparency
                ctx.clearRect(0, 0, W, H);

                // Draw optical axis
                drawOpticalAxis();

                // Draw static elements
                drawScene(scene.x, scene.y);
                drawPrism(prism1.x, prism1.y, prism1.size);
                drawMask(mask.x, mask.y, mask.width, mask.height);
                drawPrism(prism2.x, prism2.y, prism2.size);
                drawDetector(
                    detector.x,
                    detector.y,
                    detector.width,
                    detector.height,
                );
                drawCube(cube.x, cube.y, cube.size);
                drawLabels();

                // Update and draw photons
                for (const photon of photons) {
                    photon.update();
                    photon.draw();
                }

                requestAnimationFrame(animate);
            }

            // Start animation
            animate();

            // Spawn new photons periodically
            setInterval(() => {
                const inactivePhoton = photons.find(
                    (p) => p.phase === 6 || p.alpha <= 0,
                );
                if (inactivePhoton) {
                    inactivePhoton.reset();
                }
            }, 100);
        </script>
    </body>
</html>
